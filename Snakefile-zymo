import pandas as pd

# Import config, set working dir, load manifest and define default rules:
include: "Snakefile-base"

references = pd.read_table("../ref.cfg").set_index("refname", drop=False)
GENOMES = references["refname"]
del GENOMES['default']

rule finish_zymo:
    input:
        base="reticulated.base.ok", # This will ensure the base rules have finished first
        checkm=expand("checkm-{assembly}.txt", assembly=enumerate_assemblies(base_only=False, unroll=True, suffix=".fa")),
        fastmer="fastmer-result.txt",
    output: touch("reticulated.zymo.ok")
    shell: 'echo "Reticulated successfully."'

rule presetup_checkm:
    output: directory("checkm")
    shell: "mkdir checkm; cd checkm; wget https://data.ace.uq.edu.au/public/CheckM_databases/checkm_data_2015_01_16.tar.gz; tar xvf checkm_data_2015_01_16.tar.gz"

rule setup_checkm:
    conda: "environments/checkm.yaml"
    input: directory("checkm")
    output: touch("checkm_setup.ok")
    shell: "echo 'checkm/' | checkm data setRoot 'checkm/'"

rule extract_kraken_contigs:
    input:
        assembly="{assembly}",
        k2="{assembly}.k2",
    params:
        genomes=list(GENOMES),
    output:
        directory("extracted_contigs/{assembly}/")
    shell:
        "python ../scripts/extract_contigs_with_kraken.py {input.k2} {input.assembly} {output}; python ../scripts/zymo/ensure_genomes.py {output} {params.genomes}"

def checkm_pick_taxon(w):
    refname =  references["refname"].get(w.genome, 'default')
    return {
        "rank": references.loc[refname]["rank"],
        "genome": references.loc[refname]["taxon"]
    }

# This rule is a little annoying, we *should* be explicitly naming the input
# FASTA needed for the checkM bin as extracted by our kraken script.
# Unfortunately, as the extract_kraken_contigs rule output is defined as a dictionary
# we cannot explicitly name an input inside that directory without a ChildIOException.
# That rule has a python script that attempts to guarantee those files exist, so
# as long as the directory exists, we can be reasonably confident the FASTA do too.
#   As gross as it sounds, the requisite `cp` will fail if it *really* doesn't exist.
# So this isn't a particularly unsafe workaround, just a gross one.
rule checkm:
    input:
        ok="checkm_setup.ok",
        d=directory("extracted_contigs/{assembly}/")
        #fa="extracted_contigs/{assembly}/{genome}.fasta"
    output:
        working=directory("checkm-working/{assembly}/{genome}"),
        bin=directory("checkm-bins/{assembly}/{genome}/"),
        res="checkm-results/{assembly}/{genome}.tsv"
    params: p=checkm_pick_taxon
    conda: "environments/checkm.yaml"
    threads: 8
    shell: "cp extracted_contigs/{wildcards.assembly}/{wildcards.genome}.fasta {output.bin}; checkm taxonomy_wf -q -t {threads} -x fasta {params.p[rank]} {params.p[genome]:q} {output.bin} {output.working} > {output.res}"

rule merge_checkm:
    input:
        logs=expand("checkm-results/{{assembly}}/{genome}.tsv", genome=GENOMES)
    output:
        "checkm-{assembly}.txt"
    shell:
        "cat {input.logs} > {output}"

def fastmer_get_ref(genome):
    refname = references["refname"].get(genome, 'default')
    refloc = references.loc[refname]["ref"] if references.loc[refname]["ref"] != '-' else None
    if refloc and refloc.startswith("HTTP"):
        refloc = "download/refs/%s.fa" % refname
    return refloc

#from snakemake.remote.HTTP import RemoteProvider as HTTPRemoteProvider
#HTTP = HTTPRemoteProvider()
rule download_ref:
    #input: lambda w: HTTP.remote(references.loc[w.ref.replace(".fa", "")]["ref"].replace("HTTP:", ""), keep_local=True)
    params:
        remote=lambda w: references.loc[w.ref.replace(".fa", "")]["ref"].replace("HTTP:", "")
    output: "download/refs/{ref}"
    run:
        shell("wget {params.remote} -O {output}")

rule jts_fastmer:
    input:
        reference=lambda w: fastmer_get_ref(w.genome),
        assembly="{assembly}",
    output:
        res="fastmer-results/{assembly}/{genome}.tsv"
    shell: "python ../scripts/zymo/jts/fastmer.py --reference {input.reference} --assembly {input.assembly} --min-mapping-quality 10 > {output.res}"

rule merge_fastmer:
    input:
        logs=expand("fastmer-results/{{assembly}}/{genome}.tsv", genome=[g for g in GENOMES if fastmer_get_ref(g)])
    output:
        "fastmer-{assembly}.txt"
    shell:
        "cat {input.logs} | awk '!/^assembly_name/ || ++n < 2' > {output}"

rule super_merge_fastmer:
    input:
        logs=expand("fastmer-{assembly}.txt", assembly=enumerate_assemblies(base_only=False, unroll=True, suffix=".fa"))
    output:
        "fastmer-result.txt"
    shell:
        "cat {input.logs} | awk '!/^assembly_name/ || ++n < 2' | bond - ../manifest.cfg --greedy | bond - ../reads.cfg --dcol 18 > {output}"

#rule nl_align_ref:
#    shell: "minimap2 -a -x map-ont -t 12 assemblies/illumina/spades/Zymo-Isolates-SPAdes-Illumina.fasta.gz $fastq | samtools sort -@12 -m100G - -o results/$run.sorted.bam; samtools index results/$run.sorted.bam"

#rule nl_bam_stats:
#    shell: "samtools view -h results/$run.sorted.bam | python ../scripts/zymo/nickloman/bamstats.py - > results/$run.stats.txt"

#rule nl_align_summary:
#    conda: "environments/R.yaml"
#    shell: "Rscript ../scripts/zymo/nickloman/summariseStats.R results/$run.stats.txt $metadata results/$run"
